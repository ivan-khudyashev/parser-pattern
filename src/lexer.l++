/* Copyright (C) Khudyashev Ivan, 2019, bahek1983@gmail.com */
%top{
    #include "parser.hpp"
%}

/* Options */
%o fast dotall unicode
%o matcher=reflex
%o noyywrap bison-cc
%o bison-cc-namespace=test
%o bison-cc-parser=parser
%o namespace=test
%o lexer=lexer
%o lex=yylex

%{
using TToken = test::parser::token_type;
const char * token_type(TToken t);
#define YY_USER_ACTION  std::cout << "Token <- " << text() << " ->" << std::endl;
%}
/* Define names */
/* * Define helpers * */
H_NBSP                              \u{00A0}
H_ZWNBSP                            \u{FEFF}
H_SP                                \u{0020}
H_LS                                \u{2028}
H_PS                                \u{2029}
H_ZWNJ                              \u{200C}
H_ZWJ                               \u{200D}
/* * Main names * */
/* ** Separators ** */
WHITESPACE                          [\t\v\f]|{H_SP}|{H_NBSP}|{H_ZWNBSP}|\p{Zs}
LINETERMINATOR                      [\n\r]|{H_LS}|{H_PS}
LINETERMINATORSEQUENCE              (?:\n\r/[^\n])|(?:{H_LS}{H_PS}\r\n)
MULTILINECOMMENT                    "/*"(?:[^*]|(?:\*+[^*/]))*\*+\/
SINGLELINECOMMENT                   "//"[^\n\r\u{2028}\u{2029}]*
/* ** Universals ** */
UNICODEESCAPESEQUENCE               (?:u[[:xdigit:]]{4})|(?:"u{"[[:xdigit:]]{1,6}"}")
/* ** Identifiers ** */
IDENTIFIERSTART                     \p{UnicodeIdentifierStart}|[$_]|(?:\\{UNICODEESCAPESEQUENCE})
IDENTIFIERPART                      \p{UnicodeIdentifierPart}|"$"|{H_ZWNJ}|{H_ZWJ}|(?:\\{UNICODEESCAPESEQUENCE})
/* ** Numeric literals ** */
/* *** Numeric literal helpers *** */
DECIMALINTEGERLITERAL               0|(?:[1-9][[:digit:]]*)
EXPONENTPART                        [eE][+-]?[[:digit:]]+
/* *** numeric literals *** */
DECIMALLITERAL                      (?:{DECIMALINTEGERLITERAL}(?:(?:\.[[:digit:]]*{EXPONENTPART}?)|{EXPONENTPART}?))|(?:\.[[:digit:]]+{EXPONENTPART}?)
BINARYINTEGERLITERAL                0[bB][01]+
OCTALINTEGERLITERAL                 0[oO][0-7]+
HEXINTEGERLITERAL                   0[xX][[:xdigit:]]+
/* ** String literals ** */
ESCAPESEQUENCE                      \\(?:[^\n\r\u{2028}\u{2029}0-9xu]|(?:x[[:xdigit:]]{2})|{UNICODEESCAPESEQUENCE})
NULLESCAPE                          \\0/[^0-9]
DOUBLEQUOTESTRING                   \"(?:(?:[^"\\\n\r\u{2028}\u{2029}])|{ESCAPESEQUENCE}|{NULLESCAPE})*\"
SINGLEQUOTESTRING                   \'(?:(?:[^'\\\n\r\u{2028}\u{2029}])|{ESCAPESEQUENCE}|{NULLESCAPE})*\'
/* ** Regex literals ** */
REGEXBACKSLASH                      \\[^\n\r\u{2028}\u{2029}]
/* *** ] = \u{005D} *** */
/* *** \ = \u{005C} *** */
REGEXCLASS                          \[(?:{REGEXBACKSLASH}|[^\n\r\u{2028}\u{2029}\u{005D}\u{005C}])*\]
/* *** [ = \u{005B} *** */
/* *** / = \u{002F} *** */
/* *** * = \u{002A} *** */
REGEXPBODY                          (?:[^\n\r\u{2028}\u{2029}\u{002A}\u{005C}\u{002F}\u{005B}]|{REGEXBACKSLASH}|{REGEXCLASS})(?:[^\n\r\u{2028}\u{2029}\u{005C}\u{002F}\u{005B}]|{REGEXBACKSLASH}|{REGEXCLASS})*
%%
{WHITESPACE}+                       /* skip Whitespaces */
{SINGLELINECOMMENT}|{MULTILINECOMMENT} /* skip Comments */
{LINETERMINATOR}                    /* { YY_USER_ACTION return TToken::LINETERMINATOR; }*/
{LINETERMINATORSEQUENCE} 
 /* Keywords */
if                                  { YY_USER_ACTION return TToken::KW_IF; }
else                                { YY_USER_ACTION return TToken::KW_ELSE; }
dummyop                             { YY_USER_ACTION return TToken::KW_DUMMYOP; }
 /* Punctuators */
";"                                 { YY_USER_ACTION return TToken::P_SEMI; }
"("                                 { YY_USER_ACTION return TToken::P_LBRACE; }
")"                                 { YY_USER_ACTION return TToken::P_RBRACE; }
"+"                                 { YY_USER_ACTION return TToken::P_ADD; }
"-"                                 { YY_USER_ACTION return TToken::P_SUB; }
"*"                                 { YY_USER_ACTION return TToken::P_MUL; }
"/"                                 { YY_USER_ACTION return TToken::P_DIV; }
"&&"                                { YY_USER_ACTION return TToken::P_LAND; }
"="                                 { YY_USER_ACTION return TToken::P_ASSIGN; }
"=="                                { YY_USER_ACTION return TToken::P_EQ; }
"++"                                { YY_USER_ACTION return TToken::P_INC; }
"--"                                { YY_USER_ACTION return TToken::P_DEC; }
 /* Literals */
 /* * Constant-lexem literals * */
null                                { YY_USER_ACTION return TToken::L_NULL; }
true                                { YY_USER_ACTION return TToken::L_TRUE; }
false                               { YY_USER_ACTION return TToken::L_FALSE; }
 /* * Numeric literals * */
{DECIMALLITERAL}|{BINARYINTEGERLITERAL}|{OCTALINTEGERLITERAL}|{HEXINTEGERLITERAL} { YY_USER_ACTION return TToken::L_NUMERIC; }
 /* * String literals * */
{DOUBLEQUOTESTRING}|{SINGLEQUOTESTRING} { YY_USER_ACTION return TToken::L_STRING; }
 /* * Regular expression literals * */
\/{REGEXPBODY}\/{IDENTIFIERPART}*    { YY_USER_ACTION return TToken::L_REGEX; }
 /* Identifiers */
{IDENTIFIERSTART}{IDENTIFIERPART}*  { YY_USER_ACTION return TToken::IDENTIFIER; }
 /* Final rules */
<<EOF>>                             { return TToken::T_END; }
.|\n                                { return TToken::T_UNDEFINED; }
%%
const char* token_type(TToken t)
{
    int offset = (int)TToken::P_ASSIGN;
    static const char* tokens[] = {
        "P_ASSIGN",
        "P_LAND",
        "P_EQ",
        "P_ADD",
        "P_SUB",
        "P_MUL",
        "P_DIV",
        "P_USUB",
        "P_INC",
        "P_DEC",
        "KW_IF",
        "KW_ELSE",
        "LINETERMINATOR",
        "KW_DUMMYOP",
        "P_SEMI",
        "P_LBRACE",
        "P_RBRACE",
        "L_NULL",
        "L_TRUE",
        "L_FALSE",
        "L_NUMERIC",
        "L_STRING",
        "L_REGEX",
        "IDENTIFIER",
        "T_UNDEFINED",
        "T_END"
    };
    static const char error_token[] = "Wrong Token's type";
    int tokens_count = sizeof tokens / sizeof(const char*);
    if(((int)t - offset >= tokens_count)||((int)t - offset < 0)) {
        return error_token;
    }
    return tokens[(int)t - offset];
}
